{"ast":null,"code":"import _regeneratorRuntime from \"/Users/victordjasliphisitkul/Desktop/Project Official Cov/object-detection-react-victor/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/victordjasliphisitkul/Desktop/Project Official Cov/object-detection-react-victor/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { useEffect } from 'react';\nconst SCORE_DIGITS = 4;\nlet hasSpeak = false;\n\nconst getLabelText = prediction => {\n  const scoreText = prediction.score.toFixed(SCORE_DIGITS);\n  return prediction.class + ', score: ' + scoreText;\n};\n\nconst renderPredictions = (predictions, canvasRef) => {\n  const ctx = canvasRef.current.getContext('2d');\n  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // Font options.\n\n  const font = '16px sans-serif';\n  ctx.font = font;\n  ctx.textBaseline = 'top'; // predictions.forEach(prediction => {\n  //   const x = prediction.bbox[0]\n  //   const y = prediction.bbox[1]\n  //   const width = prediction.bbox[2]\n  //   const height = prediction.bbox[3]\n  //   // Draw the bounding box.\n  //   ctx.strokeStyle = '#00FFFF'\n  //   ctx.lineWidth = 4\n  //   ctx.strokeRect(x, y, width, height)\n  //   // Draw the label background.\n  //   ctx.fillStyle = '#00FFFF'\n  //   const textWidth = ctx.measureText(getLabelText(prediction)).width\n  //   const textHeight = parseInt(font, 10) // base 10\n  //   ctx.fillRect(x, y, textWidth + 4, textHeight + 4)\n  // })\n\n  predictions.forEach(prediction => {\n    var timer;\n    const x = prediction.bbox[0];\n    const y = prediction.bbox[1]; // Draw the text last to ensure it's on top.\n\n    ctx.fillStyle = '#000000';\n    ctx.fillText(getLabelText(prediction), x, y);\n    clearTimeout(timer);\n\n    if (prediction.class === \"Touch-Face\") {\n      let el = document.getElementById(\"js-body\");\n\n      if (!el.classList.contains(\"error\")) {\n        el.classList.add(\"error\");\n        speakWarn();\n        timer = setTimeout(function () {\n          el.classList.remove(\"error\");\n        }, 1500);\n      } //speakWarn();\n\n    }\n  });\n};\n\nconst speakWarn = () => {\n  const synth = window.speechSynthesis;\n  synth.pitch = 8; //synth.rate = 10;\n\n  const utter = new SpeechSynthesisUtterance(\"Don't touch your face\"); //const voices = speechSynthesis.getVoices()\n\n  utter.lang = 'en-EN';\n  utter.pitch = 1;\n  synth.speak(utter);\n};\n\nconst detectFrame = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(model, videoRef, canvasRef) {\n    var predictions;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return model.detect(videoRef.current);\n\n        case 2:\n          predictions = _context.sent;\n          renderPredictions(predictions, canvasRef);\n          requestAnimationFrame(() => {\n            detectFrame(model, videoRef, canvasRef);\n          });\n\n        case 5:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n\n  return function detectFrame(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nconst useBoxRenderer = (model, videoRef, canvasRef, shouldRender) => {\n  useEffect(() => {\n    if (model && shouldRender) {\n      detectFrame(model, videoRef, canvasRef);\n    }\n  }, [canvasRef, model, shouldRender, videoRef]);\n};\n\nexport default useBoxRenderer;","map":{"version":3,"sources":["/Users/victordjasliphisitkul/Desktop/Project Official Cov/object-detection-react-victor/src/useBoxRenderer.js"],"names":["useEffect","SCORE_DIGITS","hasSpeak","getLabelText","prediction","scoreText","score","toFixed","class","renderPredictions","predictions","canvasRef","ctx","current","getContext","clearRect","canvas","width","height","font","textBaseline","forEach","timer","x","bbox","y","fillStyle","fillText","clearTimeout","el","document","getElementById","classList","contains","add","speakWarn","setTimeout","remove","synth","window","speechSynthesis","pitch","utter","SpeechSynthesisUtterance","lang","speak","detectFrame","model","videoRef","detect","requestAnimationFrame","useBoxRenderer","shouldRender"],"mappings":"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","sourcesContent":["import { useEffect } from 'react'\n\nconst SCORE_DIGITS = 4\nlet hasSpeak = false;\n\nconst getLabelText = (prediction) => {\n    const scoreText = prediction.score.toFixed(SCORE_DIGITS)\n    return prediction.class + ', score: ' + scoreText\n}\n\nconst renderPredictions = (predictions, canvasRef) => {\n  const ctx = canvasRef.current.getContext('2d')\n  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n  // Font options.\n  const font = '16px sans-serif'\n  ctx.font = font\n  ctx.textBaseline = 'top'\n  // predictions.forEach(prediction => {\n  //   const x = prediction.bbox[0]\n  //   const y = prediction.bbox[1]\n  //   const width = prediction.bbox[2]\n  //   const height = prediction.bbox[3]\n  //   // Draw the bounding box.\n  //   ctx.strokeStyle = '#00FFFF'\n  //   ctx.lineWidth = 4\n  //   ctx.strokeRect(x, y, width, height)\n  //   // Draw the label background.\n  //   ctx.fillStyle = '#00FFFF'\n  //   const textWidth = ctx.measureText(getLabelText(prediction)).width\n  //   const textHeight = parseInt(font, 10) // base 10\n  //   ctx.fillRect(x, y, textWidth + 4, textHeight + 4)\n  // })\n\n  predictions.forEach(prediction => {\n    var timer;\n    const x = prediction.bbox[0]\n    const y = prediction.bbox[1]\n    // Draw the text last to ensure it's on top.\n    ctx.fillStyle = '#000000'\n    ctx.fillText(getLabelText(prediction), x, y)\n    clearTimeout(timer);\n    if(prediction.class===\"Touch-Face\"){\n      \n      let el = document.getElementById(\"js-body\");\n      if(!el.classList.contains(\"error\")){\n        el.classList.add(\"error\");\n        speakWarn();\n        timer = setTimeout(function(){\n          el.classList.remove(\"error\");\n        },1500)\n      }\n     \n      //speakWarn();\n\n    }\n  })\n}\nconst speakWarn = () =>{\n  const synth = window.speechSynthesis\n  synth.pitch = 8;\n  //synth.rate = 10;\n  \n  const utter = new SpeechSynthesisUtterance(\"Don't touch your face\")\n  //const voices = speechSynthesis.getVoices()\n  \n  utter.lang = 'en-EN';\n  utter.pitch = 1;\n\n  synth.speak(utter);\n}\n\nconst detectFrame = async (model, videoRef, canvasRef) => {\n  const predictions = await model.detect(videoRef.current)\n  renderPredictions(predictions, canvasRef)\n  requestAnimationFrame(() => {\n    detectFrame(model, videoRef, canvasRef)\n  })\n}\n\nconst useBoxRenderer = (model, videoRef, canvasRef, shouldRender) => {\n  useEffect(() => {\n    if (model && shouldRender) {\n      detectFrame(model, videoRef, canvasRef)\n    }\n  }, [canvasRef, model, shouldRender, videoRef])\n}\n\nexport default useBoxRenderer\n"]},"metadata":{},"sourceType":"module"}